#!/usr/bin/env python3
# -*- coding:utf-8 -*-

import sys, re
import pyqtgraph as pg

from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.uic import *

from PyQt5.QtSql import QSqlDatabase, QSqlTableModel

from iid import IID

class IID_GUI(QMainWindow):
    '''
    A GUI for showing the ion identification result
    '''
    bgcolor = "#FAFAFA"
    fgcolor = "#23373B"
    green = (27, 129, 62)   # "#1B813E"
    orange = (233, 139, 42) # "#E98B2A"
    red = (171, 59, 58)     # "#AB3B3A"
    lightgray = (211, 211, 211) # "#d3d3d3"
    bluejeans = (88, 204, 237) # "#58cced"
    _bluejeans = "#58cced"
    bluetufts = (56, 149, 211) # "#3895d3"
    _bluetufts = "#3895d3"
    bluepersian = (18, 97, 160) # "#1261a0"
    _bluepersian = "#1261a0"
    bluecool = (7, 47, 95) # "#072f5f"
    _bluecool = "#072f5f"
    
    def __init__(self):
        super().__init__()
        
        # the default parameter setting
        self.directory = "./"
        self.cen_freq = 242.5 # MHz
        self.span = 1000 # kHz

        self.set_display()
        self.build_connections()
        #self.threadPool = QThreadPool()

        self.statusBar().showMessage("Select the .lpp file, and check the 'File Load' before loading file")


    def QLineEdit_InputStyle(self, lineEdit):
        lineEdit.setStyleSheet("QLineEdit {{color : {:s}}}".format(self.fgcolor))
        lineEdit.setReadOnly(False)

    def QLineEdit_LockStyle(self, lineEdit):
        lineEdit.setStyleSheet("QLineEdit {{color: {:s}; background-color: lightgray}}".format(self.fgcolor))
        lineEdit.setReadOnly(True)

    def QCheckBox_InputStyle(self, checkBox):
        checkBox.setStyleSheet("QCheckBox {{color: {:s}}}".format(self.fgcolor))
        checkBox.setEnabled(True)

    def QCheckBox_IonTypeStyle(self, checkBox, color):
        checkBox.setStyleSheet("QCheckBox {{color: {:s}; background-color: {:s}}}".format(self.fgcolor, color))
        checkBox.setEnabled(True)

    def QCheckBox_LockStyle(self, checkBox):
        checkBox.setStyleSheet("QCheckBox {{color: {:s}; background-color: lightgray}}".format(self.fgcolor))
        checkBox.setEnabled(False)
        checkBox.setChecked(False)
        
    def spectrum_font_label(self, labs): return "<span style=font-family:Roboto;font-size=14pt>" + labs + "</span>"

    def set_display(self):
        pg.setConfigOptions(background=self.bgcolor, foreground=self.fgcolor, antialias=True, imageAxisOrder="row-major")
        loadUi("iid_GUI.ui", self) # the ui. file is generated by the Qt designer

        # set parameter
        self.cenFreqInput.setText(str(self.cen_freq))
        self.spanInput.setText(str(self.span))
        self.QLineEdit_InputStyle(self.cenFreqInput)
        self.QLineEdit_InputStyle(self.spanInput)
        self.QLineEdit_LockStyle(self.ionInput)
        self.QLineEdit_LockStyle(self.isometricStateInput)
        self.QLineEdit_LockStyle(self.calibrateBrhoInput)
        self.QCheckBox_LockStyle(self.bareCheck)
        self.QCheckBox_LockStyle(self.HLikeCheck)
        self.QCheckBox_LockStyle(self.HeLikeCheck)
        self.QCheckBox_LockStyle(self.LiLikeCheck)

        # ion spectrum
        self.spectrum = self.gSpectrum.addPlot(title=self.spectrum_font_label("Simulation of the Schottky spectrum"))
        self.spectrum.setLogMode(False, True)
        self.spectrum.setLabels(left=self.spectrum_font_label("Magnitude"), bottom=self.spectrum_font_label("Frequency - ___ MHz [kHz]"))
        # marker of the ions in spectrum
        self.crosshair_v = pg.InfiniteLine(pos=0, angle=90, pen=self.fgcolor)
        self.spectrum.addItem(self.crosshair_v, ignoreBounds=True)

        # ion information list
        self.ionTable.setSortingEnabled(True)

        # file list
        self.mFileList = QFileSystemModel(self)
        self.mFileList.setFilter(QDir.Files)
        self.mFileList.setNameFilters(["*.lpp"])
        self.mFileList.setNameFilterDisables(False)
        self.mFileList.sort(3, Qt.DescendingOrder) # sort by the fourth column, i.e. modified time
        self.fileList.setModel(self.mFileList)
        self.fileList.setRootIndex(self.mFileList.setRootPath(self.directory))
        self.fileList.hideColumn(1)
        self.fileList.hideColumn(2)
        self.fileList.hideColumn(3)

    def build_connections(self):
        '''
        build connections between buttons or checkboxs and events
        '''
        # file loading
        def check_fileLoad():
            if self.fileCheck.isChecked():
                self.QLineEdit_LockStyle(self.cenFreqInput)
                self.QLineEdit_LockStyle(self.spanInput)
                self.bareCheck.stateChanged.connect(check_ionType)
                self.HLikeCheck.stateChanged.connect(check_ionType)
                self.HeLikeCheck.stateChanged.connect(check_ionType)
                self.LiLikeCheck.stateChanged.connect(check_ionType)
                self.QCheckBox_LockStyle(self.bareCheck)
                self.QCheckBox_LockStyle(self.HLikeCheck)
                self.QCheckBox_LockStyle(self.HeLikeCheck)
                self.QCheckBox_LockStyle(self.LiLikeCheck)
                self.fileList.activated.connect(selected_file)
            else:
                self.QLineEdit_InputStyle(self.cenFreqInput)
                self.QLineEdit_InputStyle(self.spanInput)
                self.bareCheck.stateChanged.disconnect(check_ionType)
                self.HLikeCheck.stateChanged.disconnect(check_ionType)
                self.HeLikeCheck.stateChanged.disconnect(check_ionType)
                self.LiLikeCheck.stateChanged.disconnect(check_ionType)
                self.QCheckBox_IonTypeStyle(self.bareCheck, self._bluejeans)
                self.QCheckBox_IonTypeStyle(self.HLikeCheck, self._bluetufts)
                self.QCheckBox_IonTypeStyle(self.HeLikeCheck, self._bluepersian)
                self.QCheckBox_IonTypeStyle(self.LiLikeCheck, self._bluecool)
                self.fileList.activated.disconnect(selected_file)
        self.fileCheck.stateChanged.connect(check_fileLoad)

        def selected_file(model_index):
            self.load_file(model_index.data())

        # ion-types display
        def check_ionType():
            self.ionInput.setText("")
            self.plot_ionType = [(part[0], part[-1]) for part in [('BAREION', self.bareCheck.isChecked(), self.bluejeans), ('HLIKEION', self.HLikeCheck.isChecked(), self.bluetufts), ('HELIKEION', self.HeLikeCheck.isChecked(), self.bluepersian), ('LILIKEION', self.LiLikeCheck.isChecked(), self.bluecool)] if part[1]]
            self.qsqlClose() 
            self.display(self.plot_ionType)
        self.bareCheck.stateChanged.connect(check_ionType)
        self.HLikeCheck.stateChanged.connect(check_ionType)
        self.HeLikeCheck.stateChanged.connect(check_ionType)
        self.LiLikeCheck.stateChanged.connect(check_ionType)

        # ion spectrum interaction
        def on_moved_spectrum(point):
            if self.spectrum.sceneBoundingRect().contains(point):
                coords = self.spectrum.getViewBox().mapSceneToView(point)
                self.crosshair_v.setValue(coords.x())
                try:
                    ion = self.find_ions(coords.x())
                    self.statusBar().showMessage("δf = {:.5g} kHz, ion = {:6s}".format(coords.x(), ion))
                except:
                    self.statusBar().showMessage("δf = {:.5g} kHz".format(coords.x()))
        self.spectrum.scene().sigMouseMoved.connect(on_moved_spectrum)

        # ion searching
        def check_ionInput():
            if self.ionCheck.isChecked():
                self.QLineEdit_InputStyle(self.ionInput)
                self.QLineEdit_InputStyle(self.isometricStateInput)
            else:
                self.QLineEdit_LockStyle(self.ionInput)
                self.QLineEdit_LockStyle(self.isometricStateInput)
        self.ionCheck.stateChanged.connect(check_ionInput)
        
        def button_ionSearch():
            if self.ionCheck.isChecked():
                if self.ionInput.text() == "":
                    self.statusBar().showMessage("No ion input for search!")
                    return
                # processing    
                self.qsqlClose() 
                self.fileWork.search_ion(self.ionInput.text())
                if self.fileWork.cur.execute("SELECT count(name) FROM sqlite_master WHERE type='table' AND name='SEARCHION'").fetchone()[0] == 0:
                    self.ionInput.setText("")
                    self.statusBar().showMessage("No valid ions found!")
                else:
                    self.statusBar().showMessage("Search finished!")
                self.display(self.plot_ionType)
            else:
                self.statusBar().showMessage("Check the 'Ion' first!")
        self.ionButton.clicked.connect(button_ionSearch)

        # ion calibration
        def check_BrhoInput():
            if self.calibrateBrhoCheck.isChecked():
                self.QLineEdit_InputStyle(self.calibrateBrhoInput)
                self.ionCheck.setChecked(False)
                self.QLineEdit_LockStyle(self.calibratePeakLocInput)
                self.QLineEdit_LockStyle(self.calibrateHarmInput)
            else:
                self.QLineEdit_LockStyle(self.calibrateBrhoInput)
                self.ionCheck.setChecked(True)
                self.QLineEdit_InputStyle(self.calibratePeakLocInput)
                self.QLineEdit_InputStyle(self.calibrateHarmInput)
        self.calibrateBrhoCheck.stateChanged.connect(check_BrhoInput)

        def button_ionCalibrate():
            if self.calibrateBrhoCheck.isChecked():
                try:
                    if float(self.calibrateBrhoInput.text()) > 0:
                        self.Brho = float(self.calibrateBrhoInput.text())
                        pass
                except:
                    self.statusBar().showMessage("Invalid input!")
                    return
            else:
                if (not self.ionCheck.isChecked()) or (self.isometricStateInput == ""):
                    self.statusBar().showMessage("Please check the 'Ion' and give valid isometric state!")
                    return
                try:
                    if bool(re.fullmatch("(\d+)[A-Za-z]+(\d+)", self.ionInput.text())) and self.isometricStateInput.text().isdigit() and self.calibrateHarmInput.text().isdigit() and type(float(self.calibratePeakLocInput.text())) == float:
                        pass
                except:
                    self.statusBar().showMessage("Invalid input!")
                    return
                if self.fileWork.cur.execute("SELECT count(ID) FROM OBSERVEDION WHERE ION=? AND ISOMERIC=?", (self.ionInput.text(), self.isometricStateInput.text())).fetchone()[0] == 0:
                    self.statusBar().showMessage("No such ion exists!")
                    return
                self.ion = self.ionInput.text()
                self.isometric = self.isometricStateInput.text()
                self.peakLoc = float(self.calibratePeakLocInput.text())
                self.harm = int(self.calibrateHarmInput.text())

            self.QCheckBox_LockStyle(self.bareCheck)
            self.QCheckBox_LockStyle(self.HLikeCheck)
            self.QCheckBox_LockStyle(self.HeLikeCheck)
            self.QCheckBox_LockStyle(self.LiLikeCheck)
            self.statusBar().showMessage("Calibrating...")

            # processing
            self.qsqlClose() 
            if self.calibrateBrhoCheck.isChecked():
                self.fileWork.calibrate_Brho(self.Brho)
            else:
                self.fileWork.calibrate_peak_loc(self.ion, self.isometric, self.peakLoc, self.harm)
            self.ionInput.setText("")
            self.isometricStateInput.setText("")
            self.calibratePeakLocInput.setText("")
            self.calibrateHarmInput.setText("")
            self.fileWork.cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
            table_name = [part[0] for part in self.fileWork.cur.fetchall() if (part[0] != 'IONICDATA' and part[0] != 'LPPDATA' and part[0] != 'OBSERVEDION')]
            max_freq, max_peakloc = self.fileWork.cur.execute("SELECT max(HARMONIC), max(REVFREQ) FROM TOTALION").fetchall()[0]
            self.width = max_freq * max_peakloc * self.fileWork.sigma * 1e3 / 1.66
            # check the valid ion types
            ionTypeZip = [('BAREION', self.bareCheck, self._bluejeans), ('HLIKEION', self.HLikeCheck, self._bluetufts), ('HELIKEION', self.HeLikeCheck, self._bluepersian), ('LILIKEION', self.LiLikeCheck, self._bluecool)]
            for part in ionTypeZip:
                if part[0] in table_name:
                    self.QCheckBox_IonTypeStyle(part[1], part[-1])
                    part[1].setChecked(True)
            self.statusBar().showMessage("Data has been calibrated!")
        self.calibrateButton.clicked.connect(button_ionCalibrate)

    def load_file(self, data_file):
        self.QCheckBox_LockStyle(self.bareCheck)
        self.QCheckBox_LockStyle(self.HLikeCheck)
        self.QCheckBox_LockStyle(self.HeLikeCheck)
        self.QCheckBox_LockStyle(self.LiLikeCheck)
        self.statusBar().showMessage("file loading...")
        self.cen_freq = float(self.cenFreqInput.text())
        self.span = float(self.spanInput.text())

        # processing
        self.fileWork = IID(data_file, self.cen_freq, self.span, GUI_mode=True) 
        self.fileWork.calc_peak()
        self.fileWork.cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
        table_name = [part[0] for part in self.fileWork.cur.fetchall() if (part[0] != 'IONICDATA' and part[0] != 'LPPDATA' and part[0] != 'OBSERVEDION')]
        max_freq, max_peakloc = self.fileWork.cur.execute("SELECT max(HARMONIC), max(REVFREQ) FROM TOTALION").fetchall()[0]
        self.width = max_freq * max_peakloc * self.fileWork.sigma * 1e3 / 1.66
        # check the valid ion types
        ionTypeZip = [('BAREION', self.bareCheck, self._bluejeans), ('HLIKEION', self.HLikeCheck, self._bluetufts), ('HELIKEION', self.HeLikeCheck, self._bluepersian), ('LILIKEION', self.LiLikeCheck, self._bluecool)]
        for part in ionTypeZip:
            if part[0] in table_name:
                self.QCheckBox_IonTypeStyle(part[1], part[-1])
                part[1].setChecked(True)
        self.statusBar().showMessage("Selected file has been loaded!")

    def find_ions(self, coord_x):
        '''
        show the information of the selected ion peak
        '''
        ion_list = self.fileWork.cur.execute("SELECT ION FROM TOTALION WHERE PEAKLOC>=? AND PEAKLOC<=? ORDER BY ID", (coord_x-self.width, coord_x+self.width)).fetchall()[0]
        if len(ion_list) > 0:
            return ion_list[0]


    def display(self, ionType):
        '''
        flash the result of GUI display, including the ionTable and spectrum
        '''
        
        # spectrum
        self.spectrum.clear()
        frequency_range, ion_peak = self.fileWork.calc_gaussian_peak('TOTALION')
        self.spectrum.plot(frequency_range, ion_peak, pen=pg.mkPen(self.lightgray, width=2))
        for plot_i in ionType:
            frequency_range, ion_peak = self.fileWork.calc_gaussian_peak(plot_i[0])
            self.spectrum.plot(frequency_range, ion_peak, pen=pg.mkPen(plot_i[-1], width=2))
        if self.ionInput.text() == "": # search off
            if self.fileWork.cur.execute("SELECT count(name) FROM sqlite_master WHERE type='table' AND name='SEARCHION'").fetchone()[0] == 1:
                self.fileWork.cur.execute("DROP TABLE SEARCHION")
                self.fileWork.conn.commit()
            self.fileWork.cur.execute('''CREATE TABLE SEARCHION
                (ID         INT,
                ION         TEXT        NOT NULL,
                ISOMERIC    CHAR(1), 
                YIELD       REAL,
                WEIGHT      DOUBEL,
                HARMONIC    INT,         
                PEAKLOC     REAL,
                REVFREQ     REAL,     
                HALFLIFE    TEXT,
                PRIMARY KEY (ID));''')
            self.fileWork.conn.commit()
            for plot_i in ionType:
                self.fileWork.cur.execute("INSERT INTO SEARCHION SELECT * FROM %s ORDER BY ID" %plot_i[0])
            self.fileWork.conn.commit()
        else: # search on
            frequency_range, ion_peak = self.fileWork.calc_gaussian_peak('SEARCHION')
            self.spectrum.plot(frequency_range, ion_peak, pen=pg.mkPen(self.orange, width=2))
        self.spectrum.setLabels(left=self.spectrum_font_label("Magnitude"), bottom=self.spectrum_font_label("Frequency - {:g} MHz [kHz]".format(self.cen_freq)))
        self.spectrum.setRange(xRange=(-self.span/2,self.span/2))
        self.spectrum.addItem(self.crosshair_v, ignoreBounds=True)
        self.crosshair_v.setValue(0)
        # ionTable
        self.con = QSqlDatabase.addDatabase("QSQLITE", "db")
        self.con.setDatabaseName('./ionic_data.db')
        self.con.open()
        self.qsqlmodel = QSqlTableModel(None, self.con)
        self.ionTable.setModel(self.qsqlmodel)
        self.qsqlmodel.setTable('SEARCHION')
        self.qsqlmodel.select()
        self.calibrateBrhoInput.setText("{:}".format(self.fileWork.Brho))

    def qsqlClose(self):
        try:
            self.ionTable.setModel(None)
            del self.qsqlmodel
            self.con.close()
            del self.con
            QSqlDatabase.removeDatabase("db")
        except:
            pass
       
    def keyPressEvent(self, event):
        if event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_W:
            reply = QMessageBox.question(self, "Message", "Are you sure to quit?", QMessageBox.Yes|QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                sys.exit()
            else:
                return

if __name__ == '__main__':
    app = QApplication(sys.argv)
    iid_app = IID_GUI()

    iid_app.show()
    sys.exit(app.exec())
